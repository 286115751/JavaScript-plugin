<!DOCTYPE html>
<html>
<head>
	<title>面向对象的继承</title>
</head>
<body>
<script>
//继承


//【原型链】
// function SuperType() {
// 	this.property = true;
// }

// SuperType.prototype.getSuperValue = function() {
// 	return this.property;
// };

// function SubType() {
// 	this.subproperty = false;
// }

// SubType.prototype = new SuperType();

// SubType.prototype.getSubValue = function() {
// 	return this.subproperty;
// };
// var instance = new SubType();
// console.log(instance.getSuperValue());

//原型链缺陷
// function SuperType() {
// 	this.colors = ['red', 'blue', 'green'];
// }

// function SubType() {}

// SubType.prototype = new SuperType();

// var instanceA = new SubType();
// instanceA.colors.push('black');
// console.log(instanceA.colors);

// var instanceB = new SubType();
// console.log(instanceB.colors);
//【原型链】



//【借用构造函数（经典继承）】
// function SuperType(name) {
// 	this.name = name;
// 	this.colors = ['red', 'blue', 'green'];
// }

// function SubType() {
// 	SuperType.call(this, 'Daryl');
// }

// var instanceA = new SubType();
// instanceA.colors.push('black');
// console.log(instanceA.colors);

// var instanceB = new SubType();
// console.log(instanceB.colors);

//借用构造函数问题
//方法都是在子类中创建的，函数无法复用

//【借用构造函数】



//【组合继承（伪经典继承）】
// function SuperType(name) {
// 	this.name = name;
// 	this.colors = ['red', 'blue', 'green'];
// }

// SuperType.prototype.sayName = function() {
// 	console.log(this.name);
// };

// function SubType(name, age) {
// 	SuperType.call(this, name);
// 	this.age = age;
// }

// SubType.prototype = new SuperType();
// console.log(SubType.prototype.constructor); //SuperType
// SubType.prototype.constructor = SubType;
// SubType.prototype.sayAge = function() {
// 	console.log(this.age);
// };

// var instanceA = new SubType('AAA', 29);
// instanceA.colors.push('black');
// console.log(instanceA.colors);
// instanceA.sayName();
// instanceA.sayAge();

// var instanceB = new SubType('BBB', 27);
// console.log(instanceB.colors);
// instanceB.sayName();
// instanceB.sayAge();

//组合继承问题
//组合继承融合了原型链与借用构造函数的优点，避免了二者的缺陷，是最常用的继承模式。

//【组合继承】



//【原型式继承】
// function object(o) {
// 	function F() {}
// 	F.prototype = o;
// 	return new F();
// }

// var person = {
// 	name: 'ABC',
// 	firends: ['Shelby', 'Court', 'Van']
// };

// var personA = object(person);
// personA.name = 'AAA';
// personA.firends.push('Rob');

// var personB = object(person);
// personB.name = 'BBB';
// personB.firends.push('Barbie');

// console.log(person.firends);

//ES5实现原型式继承
// var person = {
// 	name: 'ABC',
// 	firends: ['Shelby', 'Court', 'Van']
// };

// var personA = Object.create(person);
// personA.name = 'AAA';
// personA.firends.push('Rob');

// var personB = Object.create(person);
// personB.name = 'BBB';
// personB.firends.push('Barbie');

// console.log(person.firends);

//原型式继承问题
//在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。
//【原型式继承】

//寄生式继承

//寄生组合式继承

</script>
</body>
</html>